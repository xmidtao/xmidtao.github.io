"use strict";(self.webpackChunkagile_docs=self.webpackChunkagile_docs||[]).push([[3513],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return m}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=p(n),m=r,k=u["".concat(s,".").concat(m)]||u[m]||d[m]||o;return n?a.createElement(k,i(i({ref:t},c),{},{components:n})):a.createElement(k,i({ref:t},c))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},5519:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return p},toc:function(){return c},default:function(){return u}});var a=n(3117),r=n(102),o=(n(7294),n(3905)),i=["components"],l={id:"introduction",title:"Integration",sidebar_label:"Integration",slug:"/core/integration"},s=void 0,p={unversionedId:"packages/core/api/integration/introduction",id:"packages/core/api/integration/introduction",title:"Integration",description:"Most UI-Frameworks already have an Integration for AgileTs.",source:"@site/docs/packages/core/api/integration/Introduction.md",sourceDirName:"packages/core/api/integration",slug:"/core/integration",permalink:"/docs/core/integration",editUrl:"https://github.com/xmidtao/documentation/tree/main/docs/packages/core/api/integration/Introduction.md",tags:[],version:"current",lastUpdatedAt:1690869614,formattedLastUpdatedAt:"8/1/2023",frontMatter:{id:"introduction",title:"Integration",sidebar_label:"Integration",slug:"/core/integration"},sidebar:"docs",previous:{title:"Persisting Data",permalink:"/docs/core/persisting-data"},next:{title:"Introduction",permalink:"/docs/react"}},c=[{value:"\ud83d\udee0 Subscriptions",id:"-subscriptions",children:[{value:"<code>Component</code> based",id:"component-based",children:[],level:3},{value:"<code>Callback</code> based",id:"callback-based",children:[],level:3}],level:2},{value:"\ud83d\udcbe Example",id:"-example",children:[{value:"\ud83d\udd35 React",id:"-react",children:[],level:3}],level:2},{value:"\ud83d\udced Props",id:"-props",children:[{value:"<code>config</code>",id:"config",children:[{value:"<code>key</code>",id:"key",children:[],level:4},{value:"<code>frameworkInstance</code>",id:"frameworkinstance",children:[],level:4},{value:"<code>bind</code>",id:"bind",children:[],level:4},{value:"<code>updateMethod</code>",id:"updatemethod",children:[],level:4}],level:3}],level:2},{value:"\ud83d\udfe6 Typescript",id:"-typescript",children:[],level:2}],d={toc:c};function u(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},"\u2757\ufe0f"),"info")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"Most UI-Frameworks already have an Integration for AgileTs.\nIn general, an Integration makes it possible to use AgileTs in a particular UI-Framework\nand helps us to bind States to Components.\nCheck ",(0,o.kt)("a",{parentName:"p",href:"/docs/frameworks"},"here")," if an Integration for your preferred UI-Framework already exists.\nIf there is no existing Integration yet, this Section might be interesting for you."))),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Integration Class")," serves an Interface to UI-Frameworks like ",(0,o.kt)("a",{parentName:"p",href:"https://reactjs.org/"},"React")," or ",(0,o.kt)("a",{parentName:"p",href:"https://vuejs.org/"},"Vue"),".\nIt allows AgileTs to bind States to UI-Components and trigger rerender on them when a bound State value changes."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"new Integration({\n  key: 'myFramework',\n  frameworkInstance: MyFramework,\n  bind: () => {\n    // Will be called during the integration process\n    // and determines whether the Framework is ready\n    return Promise.resolve(true);\n  },\n  updateMethod: (componentInstance, updatedData) => {\n    // Will be called on each State value mutation (only in Component based Subscriptions)\n    // For example, if MY_STATE value mutates from 'jeff' to 'hans'\n    // Then this method will be called with the following props:  \n    // componentInstance: Component to which the State is subscribed to\n    // updatedData: Changed data (in our case '{myState: 'hans'}')\n    // \n    // Note: Callback based Subscriptions use a callback function \n    // to cause rerender on Components and therefore don't call this method!\n  }\n});\n")),(0,o.kt)("h2",{id:"-subscriptions"},"\ud83d\udee0 Subscriptions"),(0,o.kt)("p",null,"In order to create a well-functioning Integration,\nwe need a basic understanding of how States can be bound/subscribed to Components.\nIn AgileTs, there are two different ways of doing so:"),(0,o.kt)("h3",{id:"component-based"},(0,o.kt)("inlineCode",{parentName:"h3"},"Component")," based"),(0,o.kt)("p",null,"A ",(0,o.kt)("inlineCode",{parentName:"p"},"Component based Subscription")," is intended for Components that manage their local states internally in a specific property.\nFor example in a React Class Component the ",(0,o.kt)("inlineCode",{parentName:"p"},"this.state")," property.\nOften a rerender is also triggered when the state property got changed.\nTherefore, we can merge the changed AgileTs State values into the Component state property,\nto cause a rerender on the Component."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const MY_STATE = createState('hans', {key: 'myState'});\nApp.subController.subscribeWithSubsArray(\n    MyComponent, [MY_STATE.observer]\n);\n")),(0,o.kt)("p",null,"If we now mutate the ",(0,o.kt)("inlineCode",{parentName:"p"},"MY_STATE")," value"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"MY_STATE.set('jeff');\n")),(0,o.kt)("p",null,"the ",(0,o.kt)("inlineCode",{parentName:"p"},"updateMethod()")," defined in the ",(0,o.kt)("inlineCode",{parentName:"p"},"Integration Class")," will be called with the following properties:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// ..\nupdateMethod: (componentInstance, updatedData) => {\n  console.log(componentInstance); // Returns 'MyComponent'\n  console.log(updatedData); // Returns '{myState: 'jeff'}'\n}\n// ..\n")),(0,o.kt)("p",null,"Be aware that each State needs a unique key to be properly mapped in the ",(0,o.kt)("inlineCode",{parentName:"p"},"updatedData")," object."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"updatedData = {\n  myState: 'jeff',\n  myDefaultGroup: [{id: 1, name: 'frank'}, {id: 3, name: 'hans'}],\n  myComputed: \"Hello my name is 'jeff'\"\n}\n")),(0,o.kt)("p",null,"If a State can't be represented by the ",(0,o.kt)("inlineCode",{parentName:"p"},"updatedData")," object, it will be omitted.\nThe ",(0,o.kt)("inlineCode",{parentName:"p"},"updateMethod()")," will be called anyway, even with an empty ",(0,o.kt)("inlineCode",{parentName:"p"},"updateData")," object.\nTo avoid this problem, we can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"subscribeWithSubsObject()")," method.\nThere we pass a keymap with a particular key to each Observer/Subscriber instead of an array of Observers."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"App.subController.subscribeWithSubsArray(\n   MyComponent,\n   {\n     myState: MY_STATE.observer\n   }\n);\n")),(0,o.kt)("p",null,"This way, we can ensure that each ",(0,o.kt)("a",{parentName:"p",href:"/docs/introduction#agile-sub-instance"},"Agile Sub Instance")," can be mapped into the ",(0,o.kt)("inlineCode",{parentName:"p"},"updateData")," object."),(0,o.kt)("h3",{id:"callback-based"},(0,o.kt)("inlineCode",{parentName:"h3"},"Callback")," based"),(0,o.kt)("p",null,"A ",(0,o.kt)("inlineCode",{parentName:"p"},"Callback based Subscription")," is intended for Components that don't manage their local states internally\nor don't have a specific property handling their states.\nThat is why we can't trigger a rerender by mutating a state property.\nTherefore, we came across another solution. A callback function which triggers a rerender on the particular Component.\nThis callback function will then be called instead of the ",(0,o.kt)("inlineCode",{parentName:"p"},"updateMethd()"),",\nwhenever a subscribed State mutates."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const MY_STATE = createState('hans', {key: 'myState'});\nApp.subController.subscribeWithSubsArray(\n    () => {console.log('Called callback')},\n   [MY_STATE.observer]\n);\n")),(0,o.kt)("p",null,"If we now mutate the ",(0,o.kt)("inlineCode",{parentName:"p"},"MY_STATE")," value"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"MY_STATE.set('jeff');\n")),(0,o.kt)("p",null,"the defined callback function will be called."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// console: 'Called callback'\n")),(0,o.kt)("h2",{id:"-example"},"\ud83d\udcbe Example"),(0,o.kt)("p",null,"In order to get an idea of what an actual Integration might look like.\nHere are some examples:"),(0,o.kt)("h3",{id:"-react"},"\ud83d\udd35 ",(0,o.kt)("a",{parentName:"h3",href:"https://reactjs.org/"},(0,o.kt)("inlineCode",{parentName:"a"},"React"))),(0,o.kt)("p",null,"Here you can see what the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/agile-ts/agile/tree/master/packages/react"},"React Integration")," looks like."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { Agile, flatMerge, Integration } from '@agile-ts/core';\nimport { AgileReactComponent } from './hocs/AgileHOC';\nimport React from 'react';\n\nconst reactIntegration = new Integration<typeof React, AgileReactComponent>({\n  key: 'react',\n  frameworkInstance: React,\n  // Used to update State in Class Components (Component based Subscription)\n  // Note: Functional Components use a Callback based Subscription, \n  // therefore they don't call 'updateMethod()'  \n  updateMethod(componentInstance, updatedData: Object) {\n    // Merge changes into State if some Data updated otherwise force rerender\n    if (Object.keys(updatedData).length !== 0) {\n      componentInstance.agileProps = flatMerge(\n        componentInstance.agileProps,\n        updatedData\n      );\n      componentInstance.setState(\n        flatMerge(componentInstance.state, updatedData)\n      );\n    } else {\n      componentInstance.forceUpdate();\n    }\n  },\n});\n\n// Register Integration to AgileTs before instantiation\n// So that the user don't have to integrate it manually ('App.integration(reactIntegration)')\nAgile.initialIntegrations.push(reactIntegration);\n\nexport default reactIntegration;\n")),(0,o.kt)("p",null,"However, to efficiently use AgileTs in Functional and Class Components,\nwe had to create ways to simplify the binding of States to UI-Components.\nTherefore, we created the ",(0,o.kt)("inlineCode",{parentName:"p"},"useAgile()")," Hook for Functional Components\nand the ",(0,o.kt)("inlineCode",{parentName:"p"},"AgileHOC()")," for Class Components.\nIn the following examples we visually demonstrate the difference of,\nhow much easier e.g. the ",(0,o.kt)("inlineCode",{parentName:"p"},"useAgile()")," Hook made the binding of States to Components:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"binding State with ",(0,o.kt)("inlineCode",{parentName:"p"},"useAgile()"),":"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=FunctionalComponent.ts",title:"FunctionalComponent.ts"}," useAgile(MY_STATE);\n"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"binding State manually:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=FunctionalComponent.ts",title:"FunctionalComponent.ts"}," // Simple reducer to create a 'rerender' callback\n const [, forceRender] = React.useReducer((s) => s + 1, 0);\n\n useEffect(() => {\n     // Create Callback based Subscription to bind State to Component\n     // and rerender Component whenever the State mutates\n     const subscriptionContainer = App.subController.subscribeWithSubsArray(\n         // Our rerender trigger callback\n         () => {\n             forceRender();\n         },\n         [MY_STATE.observer]\n     );\n\n     // Unsubscribe Callback based Subscription on Unmount\n     // -> cleaning up, otherwise it can lead to memory leaks\n     return () => {\n         App.subController.unsubscribe(subscriptionContainer);\n     };\n });\n")))),(0,o.kt)("p",null,"Last but not least, lets take a quick look how a simplified ",(0,o.kt)("inlineCode",{parentName:"p"},"useAgile()")," Hook looks like."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import React from 'react';\nimport {\n    Agile,\n    getAgileInstance,\n    extractObservers,\n    Observer,\n    State,\n} from '@agile-ts/core';\n\nfunction useAgile(deps: Array<State | Collection | Observer | undefined>, agileInstance?: Agile){\n    // Extract Observers from passed Agile Sub Instances\n    // Each State has an Observer, which can be subscribed to a Component\n    // Through such Observer the State is able to trigger rerenders on the subscribed Components\n    const depsArray = extractObservers(deps);\n    \n    // Trigger State, used to force Component to rerender\n    const [, forceRender] = React.useReducer((s) => s + 1, 0);\n    \n    useEffect(() => {\n        // Try to get Agile Instance from passed Instances, otherwise drop error\n        if (!agileInstance) agileInstance = getAgileInstance(depsArray[0]);\n        if (!agileInstance || !agileInstance.subController) {\n            Agile.logger.error('Failed to subscribe Component with deps', depsArray);\n            return;\n        }\n\n        // Remove undefined Observers, since we can't subscirbe a not existing Observer\n        const observers: Observer[] = depsArray.filter(\n            (dep): dep is Observer => dep !== undefined\n        );\n\n        // Create Callback based Subscription\n        // -> whenever a subscribed State mutates, this callback will be called\n        // or if its an Component based Subscription the 'updateMethod()' in the React Integration (used in AgileHOC)\n        const subscriptionContainer = agileInstance.subController.subscribeWithSubsArray(\n            () => {\n                forceRender();\n            },\n            observers,\n            key\n        );\n\n        // Unsubscribe Callback based Subscription on Unmount (cleaning up, otherwise it can lead to memory leaks)\n        return () => {\n            agileInstance?.subController.unsubscribe(subscriptionContainer);\n        };\n    }, []);\n\n    // Create return value\n    return depsArray.map((dep) => {\n        return dep?.value;\n    });\n}\n")),(0,o.kt)("h2",{id:"-props"},"\ud83d\udced Props"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"new Integration(config);\n")),(0,o.kt)("h3",{id:"config"},(0,o.kt)("inlineCode",{parentName:"h3"},"config")),(0,o.kt)("p",null,"An ",(0,o.kt)("inlineCode",{parentName:"p"},"Integration")," takes a required configuration object as its only parameter."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"new Integration<typeof React, AgileReactComponent>({\n  key: 'myFramework',\n  frameworkInstance: MyFramework,\n  bind: () => {},\n  updateMethod: (componentInstance, updatedData) => {}\n});\n")),(0,o.kt)("p",null,"Here is a Typescript Interface for quick reference. However,\neach property is explained in more detail below."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"export interface CreateIntegrationConfig<F = any, C = any>\n    extends IntegrationMethods<C> {\n    key: string;\n    frameworkInstance?: F;\n}\n\n// or without extending\n\nexport interface CreateIntegrationConfig<F = any, C = any> {\n    key: string;\n    frameworkInstance?: F;\n    bind?: (agileInstance: Agile) => Promise<boolean>;\n    updateMethod?: (componentInstance: C, updatedData: Object) => void;\n}\n")),(0,o.kt)("br",null),(0,o.kt)("h4",{id:"key"},(0,o.kt)("inlineCode",{parentName:"h4"},"key")),(0,o.kt)("p",null,"The required property ",(0,o.kt)("inlineCode",{parentName:"p"},"key/name")," should be a unique ",(0,o.kt)("inlineCode",{parentName:"p"},"string/number")," to identify the Integration later."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'new Integration({\n  key: "myIntegration"\n  // ..\n});\n')),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Type"),(0,o.kt)("th",{parentName:"tr",align:null},"Default"),(0,o.kt)("th",{parentName:"tr",align:null},"Required"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"string \\| number")),(0,o.kt)("td",{parentName:"tr",align:null},"undefined"),(0,o.kt)("td",{parentName:"tr",align:null},"Yes")))),(0,o.kt)("br",null),(0,o.kt)("h4",{id:"frameworkinstance"},(0,o.kt)("inlineCode",{parentName:"h4"},"frameworkInstance")),(0,o.kt)("p",null,"An Instance of the Framework the Integration represents."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"new Integration({\n  frameworkInstance: MyFramework\n  // ..\n});\n")),(0,o.kt)("p",null,"For example, in the case of ",(0,o.kt)("a",{parentName:"p",href:"https://reactjs.org"},"React"),", it should be the ",(0,o.kt)("inlineCode",{parentName:"p"},"React")," Instance."),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Type"),(0,o.kt)("th",{parentName:"tr",align:null},"Default"),(0,o.kt)("th",{parentName:"tr",align:null},"Required"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"any")),(0,o.kt)("td",{parentName:"tr",align:null},"undefined"),(0,o.kt)("td",{parentName:"tr",align:null},"No")))),(0,o.kt)("br",null),(0,o.kt)("h4",{id:"bind"},(0,o.kt)("inlineCode",{parentName:"h4"},"bind")),(0,o.kt)("p",null,"Will be called during the integration process\nand determines whether the Framework is ",(0,o.kt)("inlineCode",{parentName:"p"},"ready"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"new Integration({\n  bind: () => {\n    const isReady = /* Some conditions */;\n    return Promise.resolve(isReady);\n  }\n  // ..\n});\n")),(0,o.kt)("p",null,"For example, it can be used to configure some things before the Framework is integrated into AgileTs."),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Type"),(0,o.kt)("th",{parentName:"tr",align:null},"Default"),(0,o.kt)("th",{parentName:"tr",align:null},"Required"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"(agileInstance: Agile) => Promise<boolean>")),(0,o.kt)("td",{parentName:"tr",align:null},"undefined"),(0,o.kt)("td",{parentName:"tr",align:null},"No")))),(0,o.kt)("br",null),(0,o.kt)("h4",{id:"updatemethod"},(0,o.kt)("inlineCode",{parentName:"h4"},"updateMethod")),(0,o.kt)("p",null,"Will be called as soon as a State subscribed to a Component (",(0,o.kt)("inlineCode",{parentName:"p"},"componentInstance"),") mutates."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"new Integration({\n  updateMethod: (componentInstance, updatedData) => {\n    // For example, if MY_STATE value mutates from 'jeff' to 'hans'\n    // Then this method will be called with the following props:  \n    // componentInstance: Component to which the State is subscribed to\n    // updatedData: Changed data (for instance '{myState: 'hans'}')\n  }\n  // ..\n});\n")),(0,o.kt)("p",null,"Be aware that this is only the case if it is a ",(0,o.kt)("a",{parentName:"p",href:"#component-based"},(0,o.kt)("inlineCode",{parentName:"a"},"Component based Subscription")),".\nIn ",(0,o.kt)("a",{parentName:"p",href:"#callback-based"},(0,o.kt)("inlineCode",{parentName:"a"},"Callback based Subscription")),", a callback function will be called to trigger a rerender on the Component\ninstead of the ",(0,o.kt)("inlineCode",{parentName:"p"},"updateMethod()"),"."),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Type"),(0,o.kt)("th",{parentName:"tr",align:null},"Default"),(0,o.kt)("th",{parentName:"tr",align:null},"Required"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"(componentInstance: C, updatedData: Object) => void")),(0,o.kt)("td",{parentName:"tr",align:null},"undefined"),(0,o.kt)("td",{parentName:"tr",align:null},"No")))),(0,o.kt)("h2",{id:"-typescript"},"\ud83d\udfe6 Typescript"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Integration Class")," is almost 100% typesafe."))}u.isMDXComponent=!0}}]);